# Basic relations

In this tutorial we will create a simple Todo MVC API with [Flask](https://flask.palletsprojects.com/en/1.1.x/) and [sqlite3](https://sqlite.org/index.html) with two models or tables, Users and Todos with a [one-to-many](https://en.wikipedia.org/wiki/One-to-many_(data_model)) relationship between users and todos.

- [Basic relations](#basic-relations)
  - [Prerequisites](#prerequisites)
  - [Tutorial](#tutorial)
    - [Setup](#setup)
    - [Project layout](#project-layout)
    - [Define the models](#define-the-models)
      - [One to many relationship - basics](#one-to-many-relationship---basics)
      - [One to many relationship - Python code](#one-to-many-relationship---python-code)
    - [Flask handlers](#flask-handlers)
    - [Verifying the api](#verifying-the-api)
    - [Bonus](#bonus)

## Prerequisites

This tutorial assumes the following: 

* you understand Git
* you can setup a new project with you IDE of choice (the tutorial is using Pycharm)
* you are comfortable with setting up a Flask web app
* you understand what a web API is
* you are comfortable setting up basic session token authentication 
* you are comfortable declaring and using models with [SQLAlchemy wrapper](https://github.com/jpsca/sqla-wrapper).
* you installed [httpie](https://httpie.io/docs) or [postman](https://www.postman.com/) to try the api routes.

If you are not, I advise you to dive into this topic before you continue with this one.


## Tutorial 

### Setup

Create a new project and install the dependencies.

```bash
git init
pip install flask python-dotenv sqla_wrapper
pip freeze > requirements.txt
```

### Project layout


```bash
simple-relations
  |- .git/          # git folder, autogenerated
  |- venv/          # python virtual environment, venv is the default for Pycharm
  |- .flaskenv      # development env variables
  |- main.py        # Flask app setup and handlers
  |- models.py      # SQLAlchemy models and database connection
  |- app.db         # sqlite database file
```

*Note*: some files and folders might have different names depending in your naming preferences and the IDE/package you are using to manage you Python virtual environment.

### Define the models

First let's declare two models, a `user` models with some simple custom authentication.

```python
# file: models.py
from sqla_wrapper import SQLAlchemy

...


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(42), unique=True)
    password = db.Column(db.String)
    session_token = db.Column(db.String, nullable=True)
```

Now lets create a `Todo` class with a *title* and a task *description*.

```python
# file: models.py

...

class Todo(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(42))
    content = db.Column(db.String)
```


#### One to many relationship - basics

Now that our models, let's add a *relationship* to them. A relationship is basically a column with a *ForeignKey*, a unique value from a row in a different table.

Let's say we have the following tables.

*Persons*

| id | name | surname |
|----|------|---------|
| 1  | Mike | Magic   |
| 2  | John | Doe     |

*Items*

| id | name                     |
|----|--------------------------|
| 1  | Laptop                   |
| 2  | Lamp                     |
| 3  | Laptop                   |
| 4  | Desk                     |
| 5  | Desk                     |
| 6  | Chair                    |
| 7  | Chair                    |
| 8  | Harry Potter novelty mug |

In order for us to "link" an item to a person the easiest way is to add a column with a reference or a foreign key to the `person` row or entry the item belongs to.

*Items*

| id  | name   | person_id |
|-----|--------|-----------|
| 1   | Laptop | 1         |
| 2   | Lamp   | 1         |
| 3   | Laptop | 2         |

Now we know that item with id `1` belong to person with id `1` and item with id `3` belong to person with id `2`. This simple trick is the gist of SQL relationships. 

Pay special attention to the fact that the *person* table has no knowledge of items, only *items* are "aware" of the person they belong to. This is important for **two** reasons:

- relationships are crated on one table only
- they are created on the table where we have multiple rows with the same reference or foreign key, like we see with our `lamp` item, that has the same `person_id` like item with id `1`

#### One to many relationship - Python code

Now to update our models. The only model we need to update in order to create a relationship is the `Todo` model.

```python
# file: models.py

...

class Todo(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(42))
    content = db.Column(db.String)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"))
```

Before we go on, let's stop here for a second and unpack this last line.

We add a new column to our `Todo` class named `user_id`. The name can be anything you desire, for example `owner`, but `user_id` makes it more understandable.

The type of the column is `db.Integer`. The type has to match the type of the column we are referring to, in our case this is the `id` from our `User` model.

Notice that the argument for `db.ForeignKey` is a string and the value is `users.id`. The string is a combination of the **name** of the table and the name of the column. The default table name is the plural name of your model name, e.g. `User` -> `users`, `Todo` -> `todos` or the value you define in the `__tablename__` property of your model. In our case this is `users.id`.


This is enough to have our relationship set up in our database, but in order to get all `todo` items when we get a `user`, we need to get all the todos where the `user_id` is the same as the `id` of the user we are retrieving.

Lucky for us this is a trivial thing when using `SQLAlchemy`. 

```python
# file: models.py
...

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(42), unique=True)
    password = db.Column(db.String)
    session_token = db.Column(db.String, nullable=True)

    todos = db.relationship("Todo")
```

What we did here is we added a *virtual* column to our model. The column is a `list` of the class instances we are referring to, in our case the `Todo` class. Now SQLAlchemy will include all the todos that "belong" to a single user or row in our `users` table.

### Flask handlers

Let's create our `api`.

```python
# file: main.py
from typing import Dict, List

from flask import Flask, requests

from models import db, Todo

...

@app.route("/users", methods=["GET", "POST"])
def create_or_get_todos() -> None:
    """Creates a user or gets *all* saved users, including their todos""" 
    if request.method == "POST":
        # create user
        ...

    users: List[USer] = db.query(User).all()
    
    # NOTE:
    # ----
    # Users are instances of the User class and need to be serialized
    response_data = []

    for user in users:
        todos = [
            {"id": todo.id, "title": todo.title, "content": todo.content} 
            for todo in user.todos
        ]
        user_as_dict = {
            "id": user.id,
            "email": user.email,
            "todos": todos
        }
        response_data.append(todo_as_dict)
    
    return response_data


@app.route("/users/todo", methods=["PUT"])
def add_todo(user_id: int) -> None:
    """Add a todo to a user""" 
    user: User = db.query(User).get(int(user_id))

    if not user:
        # NOTE:
        # ----
        # This is a basic 404, a custom might be in place
        return {}, 404
    
    # NOTE:
    # ----
    # For a production/real world app incoming data validation is a *must*
    data: Dict[str, str] = request.get_json()
    todo = Todo(title=data["title"], content=data["content"])

    # Add the todo to the virtual property of our user and update the user
    # SQLAlchemy will take care of the rest for you
    user.todos.append(todo)

    db.add(user)
    db.commit()
    

    # Serialize the user
    todos = [
        {"id": todo.id, "title": todo.title, "content": todo.content} 
        for todo in user.todos
    ]
    user_as_dict = {
        "id": user.id,
        "email": user.email,
        "todos": todos
    }
    
    return user_as_dict
```

### Verifying the api

Start the app with `flask run` and give it a quick try.

First, let's create a user

```bash
$ http POST ":5000/api/v1/user" email="mike@test.si" password="mike"

HTTP/1.0 201 CREATED
Content-Length: 58
Content-Type: application/json
Date: Mon, 01 Jan 2021 00:00:00 GMT
Server: Werkzeug/1.0.1 Python/3.7.3

{
    "email": "mike@test.si",
    "id": 1,
    "todos": []
}

```

And now assign a todo to him

```bash
http PUT ":5000/users/1/todo" title="Buy milk" content="But 12 gallons of it"

HTTP/1.0 200 SUCCESS
Content-Length: 157
Content-Type: application/json
Date: Mon, 01 Jan 2021 00:00:00 GMT
Server: Werkzeug/1.0.1 Python/3.7.3

{
    "email": "mike@test.si",
    "id": 1,
    "todos": [
        {
            "content": "But 12 gallons of it",
            "id": 1,
            "title": "Buy milk"
        }
    ]
}
```

That's it :)

### Bonus

* add due date to todos, make sure to serialize the incoming data
* add incoming data validation by adding class methods to models or by using a library like [pydantic](https://pydantic-docs.helpmanual.io/)
* add serialization methods to your models, create a helper function or use a library like [flask-marshmallow](https://flask-marshmallow.readthedocs.io/en/latest/)
* add pagination
* add reusable 404 responses

