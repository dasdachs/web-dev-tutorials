# Intro to APIs

In this tutorial we will create a small API for movies. Since this will be an intro to APIs, there will be no databases, API documentation, testing etc. 

- [Intro to APIs](#intro-to-apis)
  - [Prerequisites](#prerequisites)
  - [Tutorial](#tutorial)
    - [Setup](#setup)
    - [Project layout](#project-layout)
    - [Intro to Web APIs](#intro-to-web-apis)
    - [Web APIs](#web-apis)
    - [Some REST API design rules](#some-rest-api-design-rules)
      - [Think of your data as resources](#think-of-your-data-as-resources)
      - [Use and accept JSON](#use-and-accept-json)
      - [Use HTTP to design the API](#use-http-to-design-the-api)
    - [Create the movies REST API](#create-the-movies-rest-api)
    - [Verify our movies REST API](#verify-our-movies-rest-api)
  - [Additional resources](#additional-resources)
  - [Bonus](#bonus)

## Prerequisites

This tutorial assumes the following: 

* you understand Git
* you can setup a new project with you IDE of choice (the tutorial is using Pycharm)
* you are comfortable with setting up a Flask web app
* you know about the MVC model and understand it
* you understand what a web API is
* you can create and use a database connection 
* you are comfortable declaring and using models with [SQLAlchemy wrapper](https://github.com/jpsca/sqla-wrapper).
* you installed [httpie](https://httpie.io/docs) or [postman](https://www.postman.com/) to try the api routes.

If you are not, I advise you to dive into this topic before you continue with this one.

## Tutorial

### Setup

Create a new project and install the dependencies.

```bash
git init
pip install flask python-dotenv
pip freeze > requirements.txt
```

### Project layout


```bash
simple-relations
  |- .git/          # git folder, autogenerated
  |- venv/          # python virtual environment, venv is the default for Pycharm
  |- .flaskenv      # development env variables
  |- main.py        # Flask app and our api handlers
```

*Note*: some files and folders might have different names depending in your naming preferences and the IDE/package you are using to manage you Python virtual environment.


### Intro to Web APIs

When we talk about APIs (Application Programming Interface) in *web development* we are talking about [url](https://developer.mozilla.org/en-US/docs/Web/API/URL) endpoints that do not return a HTML document or a view, but rather data or a data structure that is meant to be consumed by an application, your code). 

Say we have a web applications with and endpoint - a route in Flask - like this `/movies/life-of-brian`.

```python
from typing import Dict, List, Union

from flask import Flask, render_template_string

...

MOVIES = [
    {
        "id": 1,
        "title": "Monty Python and the Holy Grail",
        "year": 1975,
        "actors": [
            {
                "id": 1,
                "name": "Graham Chapman"
            },
            {
                "id": 2,
                "name": "John Cleese"
            },
            {
                "id": 3,
                "name": "Eric Idle"
            },
            {
                "id": 4,
                "name": "Terry Gilliam"
            },
            {
                "id": 5,
                "name": "Terry Jones"
            },
            {
                "id": 6,
                "name": "Michael Palin"
            },
            {
                "id": 7,
                "name": "Connie Booth"
            }
        ]
    },
    {
        "id": 2,
        "title": "Life of Brian",
        "year": 1979,
        "actors": [
            {
                "id": 1,
                "name": "Graham Chapman"
            },
            {
                "id": 2,
                "name": "John Cleese"
            },
            {
                "id": 3,
                "name": "Eric Idle"
            },
            {
                "id": 4,
                "name": "Terry Gilliam"
            },
            {
                "id": 5,
                "name": "Terry Jones"
            },
            {
                "id": 6,
                "name": "Michael Palin"
            },
            {
                "id": 8,
                "name": "Terence Bayler"
            },
            {
                "id": 9,
                "name": "Carol Cleveland"
            }
        ]
    },
    {
        "id": 3,
        "title": "The Meaning of Life",
        "year": 1983,
        "actors": [
            {
                "id": 1,
                "name": "Graham Chapman"
            },
            {
                "id": 2,
                "name": "John Cleese"
            },
            {
                "id": 3,
                "name": "Eric Idle"
            },
            {
                "id": 4,
                "name": "Terry Gilliam"
            },
            {
                "id": 5,
                "name": "Terry Jones"
            },
            {
                "id": 6,
                "name": "Michael Palin"
            },
            {
                "id": 9,
                "name": "Carol Cleveland"
            }
        ]
    }
]


@app.route("/movies/<movie_id>", methods=["GET"])
def get_movie(movie_id: str) -> None:
    # NOTE:
    # -----
    # Since HTTP is a text based protocol user inputs
    # must be cast (converted) to the correct data type
    # A real world app would have data validation and sanitizing
    movie_id = int(movie_id)
    data = None

    for movie in MOVIES:
        if movie.get("id") == movie_id:
            data = movie
            break

    if not data:
        return render_template_string(
            """
            <div>
                <h1>Not found</h1>
                <p>The movie with id {{ movie_id }} was not found</p>
            </div>
            """,
            movie_id=movie_id
        )

    return render_template_string(
        """
        <div>
            <h1>{{ movie.title }}</h1>
            <p>Released:{{ movie.year }} </p>

            <h2>Actors: </h2>
            <ul>
                {% for actor in movie.actors  %}
                <li>{{ actor.name }}</li>
                {% endfor %}
            </ul>
        </div>
        """,
        movie=data
    )


@app.route("/actors/<actor_id>")
def get_actor_data(actor_id: str) -> None:
    # NOTE:
    # -----
    # Same comment as in the movies handler
    actor_id = int(actor_id)

    actor: Dict[str, Union[int, None, str, List[str]]] = {
        "id": actor_id,
        "name": None,
        "movies": []
    }

    for movie in MOVIES:
        for act in movie.get("actors", []):
            if act.get("id") == actor_id:
                # NOTE:
                # -----
                # This is just an example, so this part is a bit weird
                # In real apps we would first get the actors data and then
                # add all the movies, so checking for the actors name would
                # not be necessary
                name = actor.get("name")
                if not name:
                    actor["name"] = act.get("name")

                actor["movies"].append(movie)

    if not actor.get("name"):
        return render_template_string(
            """
            <div>
                <h1>Not found</h1>
                <p>Actor with id {{ actor_id }} was not found</p>
            </div>
            """,
            actor=actor
        )

    return render_template_string(
        """
        <div>
            <h1>{{ actor.name }}</h1>

            <h2>Appears in: </h2>

            <ul>
                {% for movie in actor.movies  %}
                <li>{{ movie.title }}</li>
                {% endfor %}
            </ul>
        </div>
        """,
        actor=actor
    )

```

We see two things:

* the handler `get_movie`returns a view (function), `render_template_string` that returns the a HTML document with our data
* the controller and view function are tightly coupled, meaning if we wanted to changes the UI we would need to change it in the handler. 
  Putting the template into separate html files does not change this.

If you are building an app that also renders the view aka the UI part, the described approach is good and you do not need to change anything. But if you are having different clients that consume your web app, say a web app and mobile apps or you are building a SPA (single page application), then the view part is not part of you web app anymore. "All" your web app needs to do is to serve data that the client can use for its view functions.


### Web APIs

Lucky the described engineering problem has been solved *to death*, so we can once again stand on the proverbial shoulders of giants. We need a RESTFul API.

> A REST API (also known as RESTful API) is an application programming interface (API or web API) that conforms to the constraints of 
> REST architectural style and allows for interaction with RESTful web services
> [RedHat](https://www.redhat.com/en/topics/api/what-is-a-rest-api)

We will make use of the flexibility of the *HTTP* protocol to refactor our web app in such a manor that the client can easily discover and retrieve data for its view functions.

To represent the data we use another web standard: [JSON](https://www.json.org/json-en.html). JSON is wildly supported, easy to work with and is probably the most human readable data structure. Keep in mind that our API could be returning different data formats, like *XML*.

### Some REST API design rules

There are lots of heated debates regarding the design and implementation of the REST API definitions which we will skillfully avoid. You are encouraged however to read through the links at the end of this tutorial.

We can however sum up the most important parts of the REST API design:

#### Think of your data as resources

Each endpoint should belong to a resource or a collection of resources, e.g. the endpoint `/api/movies` represents the interface for the collection of the movie resource. A resource can be an object, a row from a table in a database or a combinations of any of them.

#### Use and accept JSON

Always return JSON. If possible allow the user to send JSON as well. Use others types, for example Form Data, only in cases where JSON is not an option, like say uploading files.

#### Use HTTP to design the API

When designing (writing the routes) of your REST API try to minimize the number of routes using HTTP *methods* or *verbs*.

```
/movies         GET     # Get all movies
/movies         POST    # Create a movie resource

/movies/<id>    GET     # Get a single movie by id
/movies/<id>    PUT     # Get a single movie by id and update it
/movies/<id>    DELETE  # Get a single movie by id and delete it
```

If our *movie* resource would include *actors*, the *actors* resource would probably have its own endpoint, say `/actors` and would also be nested under the `movie` url.

```
/movies/<id>/actors                GET      # Get all the actors for a single movie
/movies/<id>/actors                PUT      # Add an actor to a movie 

/movies/<id>/actors/<actor_id>     GET      # Get an actor by id
/movies/<id>/actors/<actor_id>     PUT      # Get an actor by id and update the resource
/movies/<id>/actors/<actor_id>     PUT      # Get an actor by id and delete the resource
```

The name of the *resource* is a noun, plural if we expect that the root endpoint returns a list of resources - a collection. The actions are defined by the HTTP methods or verbs that are allowed for a single resource.

And since we are "designing" and "consuming" the API with the HTTP protocol, a nice addition is to add the correct [HTTP codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) to our responses.

* 2xx marks successful requests, e.g. 200 OK
* 3xx marks redirects and caches, e.g. 304 Moved Permanently
* 4xx marks client errors, e.g. 404 Not found
* 5xx marks server error, e.g. 500 Internal Server Error

### Create the movies REST API

Let's reuse our movies code from above and refactor it into a REST API.

Just for clarity we will add `api` to our route and add a version. All our endpoints will have a prefix like this `/api/v1/`. 

For brevity lets assume the data has not changed and that we created a python file called `modules.py` with two classes, `Movie` and `Actor`. These classes have the following class methods to help us with our [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) operations:

* `get_all() -> List[Dict]`: gets a collection of resources (a list)
* `create(data: Dict) -> Dict`: gets a collection of resources (a list)
* `get_one(id: int) -> Optional[Dict]: gets one resource
* `update(id: int, data: Dict) -> Optional[Dict]`: update a selected resource
* `delete(id: int) -> bool`: removes one resource

One more thing, keep in mind that in a real application the data would probably be stored in a database so you would need to consider marshaling, that is converting from class to a list/dictionary that can be dumped to JSON and converting from a JSON to a class instance. 


```python
from flask import Flask, jsonify, request

from models import Movie, Actor

...

@app.route("/api/v1/movies/, methods=["GET", "POST"])
def get_all_or_create_movie():
    if request.method == "POST":
        # NOTE: data validation required
        data = request.get_json()

        movie = Movies.create(data)

        return data, 201
    
    movies = Movie.get_all()
    
    return movies


@app.route("/api/v1/movies/<movie_id>, methods=["GET", "PATCH", "DELETE"])
...

@app.route("/api/v1/movies/<movie_id>/actors/, methods=["GET", "PUT"])
def get_or_add_actor_to_movie(move_id: str) -> None:
    # NOTE: user input validation required
    movie_id = int(move_id)

    movie = Movie.get_one(move_id)

    if not movie:
        return {"msg": f"Movie with id {movie_id} not found"}, 404
    
    if request.method == "PUT":
        data = request.get_json()

        # NOTE: a real world app would do this different
        actor = Actor.create(data)
        movie["actors"].append(actor)

        return movie, 200

    return movie["actors"]

...

```

## Additional resources

- https://www.freecodecamp.org/news/what-is-an-api-in-english-please-b880a3214a82/
- https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design
- https://www.redhat.com/en/topics/api/what-is-a-rest-api
- https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/
- https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9


## Bonus

* use HTTPie, curl or Postman to test your API
* add incoming data validation and invalid data error handling by adding class methods to models or by using a library like [pydantic](https://pydantic-docs.helpmanual.io/)
* create models and store them in a database
* add serialization methods to your models, create a helper function or use a library like [flask-marshmallow](https://flask-marshmallow.readthedocs.io/en/latest/)
* document your api with [Swagger](https://swagger.io/) and/or OpenAPI(https://www.openapis.org/)
* create a [Postman collection](https://www.postman.com/) and add it to you repository in a directory called `docs`
* test your api with [pytest] or the build it [Unittest library](https://docs.python.org/3/library/unittest.html)
